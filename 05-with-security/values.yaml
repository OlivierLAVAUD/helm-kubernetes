# Application Configuration
replicaCount: 1

# High Availability Configuration
highAvailability:
  enabled: false
  minReplicas: 3
  maxReplicas: 10
  podAntiAffinity: true
  topologyKey: "kubernetes.io/hostname"
  spreadConstraints:
    - maxSkew: 1
      topologyKey: "kubernetes.io/hostname"
      whenUnsatisfiable: "ScheduleAnyway"
    - maxSkew: 1
      topologyKey: "topology.kubernetes.io/zone"
      whenUnsatisfiable: "ScheduleAnyway"
  podDisruptionBudget:
    enabled: true
    minAvailable: 2
  multiZone: false
  zones: []

# Image Configuration
image:
  repository: nginx
  tag: alpine
  pullPolicy: IfNotPresent
  # Security context for the container
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop: ["ALL"]
    seccompProfile:
      type: "RuntimeDefault"

# Service Configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 80

# Nginx Configuration
nginxConfig:
  enabled: true
  configMapName: "nginx-config"
  defaultConfig: |
    server {
        listen 80;
        server_name localhost;
        
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
            try_files $uri $uri/ /index.html;
        }
        
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
        
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root /usr/share/nginx/html;
        }
        
        location ~ /\. {
            deny all;
        }
    }
  extraConfigs: {}

# Security Configuration
security:
  # Pod Security Context
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    fsGroupChangePolicy: "OnRootMismatch"
    seccompProfile:
      type: "RuntimeDefault"
  # Network Policies
  networkPolicy:
    enabled: false
    ingress:
      - from:
          - podSelector:
              matchLabels:
                app: simple-app
        ports:
          - protocol: TCP
            port: 80

# Service Account Configuration
serviceAccount:
  create: true
  name: "simple-app-sa"
  annotations: {}
  rbac:
    create: true
    rules:
      - apiGroups: [""]
        resources: ["pods", "services", "endpoints"]
        verbs: ["get", "list", "watch"]
      - apiGroups: ["apps"]
        resources: ["deployments", "replicasets"]
        verbs: ["get", "list", "watch"]
      - apiGroups: ["networking.k8s.io"]
        resources: ["ingresses"]
        verbs: ["get", "list", "watch"]

# Autoscaling Configuration
autoscaling:
  enabled: false
  hpaName: ""
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Resource Limits
resources:
  requests:
    memory: "64Mi"
    cpu: "50m"
  limits:
    memory: "128Mi"
    cpu: "100m"

# Health Checks
livenessProbe:
  httpGet:
    path: /health
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  httpGet:
    path: /health
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 1
  successThreshold: 1

startupProbe:
  httpGet:
    path: /health
    port: 80
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30

# Additional Settings
labels: {}
annotations: {}
nodeSelector: {}
tolerations: []
affinity: {}

# Ingress Configuration
ingress:
  enabled: false
  className: "nginx"
  annotations: {}
  hosts:
    - host: "myapp.local"
      paths:
        - path: "/"
          pathType: "Prefix"
  tls: []

# Monitoring and Observability
monitoring:
  enabled: false
  serviceMonitor:
    enabled: false
    interval: 30s
    scrapeTimeout: 10s
  prometheusRule:
    enabled: false
    rules: []